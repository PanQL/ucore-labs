## lab7 实验报告  

---

### 知识点  

-----

#### 本次实验涉及到如下知识点:  

* 中断的禁用与开启
* 信号量相关的知识
* 条件变量与管程相关知识
* 哲学家就餐问题

#### 以下知识点没有涉及,我认为也很重要:  

* 死锁问题
* 进程间通信
* 读者-写者问题

### 练习0  

---

* 每一次时钟中断来临时改为调用`run_timer_list`，而不是调用`sched_class_proc_tick`

### 练习1  

---

在实现信号量时，使用到了等待队列`wait_queue_t`。等待队列中的元素称为等待对象(wait),实际上就是由进程指针和某些标志构成的结构体。

一个信号量维护了一个数值和一个等待队列.对数值的修改必须通过关中断来保证为原子操作,而对数值的状态判断某些时候引发对等待队列的动作.下面就up和down两种操作进行说明:

#### down操作:

首先判断信号量对应的数值是否大于0,

* 如果大于0说明该信号量当前未被占用,将该信号量减一后直接返回.
* 否则说明该信号量正在被占用,此时可以将当前进程放入等待队列,运行调度器进行调度.等到再次回到当前这一线程,当前线程可以将自己从等待队列中取出.

#### up操作:  

当进行up操作时,可以理解为当前进程正准备放弃信号量的使用权.此时应该判断该信号量的等待队列是否为空.

* 如果等待队列为空,则说明当前没有进程在等待使用这一信号量,将数值加一之后返回即可.
* 如果等待队列不为空,则说明有进程正在等待这一信号量,唤醒等待队列的队头.

为了给用户态提供信号量，一种可能的方法是:

* 将内核中的down/up操作,包装成系统调用供用户进程使用。
* 实现用于用户向内核申请/释放信号量对象的系统调用。
* 但是用户应该只能使用信号量,而不应该能够掌握信号量的指针(过于危险).所以,还需要对用户可以看见的信号量做一层封装和映射,比如为每一个进程,维护一个数组,数组中的元素为信号量指针或者信号量.用户只能得到对应信号量在数组中的下标.系统调用时用户可以将下标和需要的操作传给内核,由内核来完成信号量的处理.

### 练习2  

----

条件变量的实现是基于信号量的.由于已经在练习1中叙述了信号量的实现机制,在此认为信号量的使用是完全可靠的.对于条件变量的实现,主要需要实现的是signal操作以及wait操作.

#### signal操作:  

signal操作代表当前进程请求修改条件变量,主要做的事情有:

* 判断是否有等待者,
  * 如果没有则直接返回;
  * 如果有等待者,将管程中的next计数器加一,表示当前进程将会被其他等待者阻塞.然后通过条件变量的信号量的等待队列通知首位等待者,将其唤醒.利用next条件变量,可以在别的进程使用管程完毕时得到通知从而被唤醒.之后将next计数器减一,因为被唤醒之后条件变量的等待进程数应当减一.

从而完成本次操作.

#### wait操作:  

wait操作往往发生在当前进程已经不需要修改条件变量的时候,此时当前进程主动要求进入等待状态,将条件变量让给其他线程.应该做的事情有:

* 将等待者计数器加一,以说明当前进程进入等待状态.然后,通过next信号量释放管程的控制权,唤醒(可能存在的)被阻塞的signal进程.
* 接着开始进入等待状态,等待使用信号量的signal进程发来信号,重新取得对管程的控制权,此时将管程的等待者计数器减一.

由于上面已经讨论了一个给用户态提供信号量的方法，要为用户态提供条件变量，可以直接把内核态条件变量的实现复制到用户态，只是将其中信号量的操作改为调用上述相应的系统调用。

#### 能否不基于信号量来实现管程?  

我认为可以不基于信号量来实现管程.但是实现管程必须基于某种互斥访问的机制,根据这种机制来实现对一个变量的互斥访问.比如互斥锁或者自旋锁.下面简单描述用某种锁结合等待队列实现条件变量的思路.

#### wait操作:  

* 关中断
* 当前进程释放锁
* 当前进程进入等待队列
* 打开中断
* 启动调度器,通知其他进程执行
* 关中断
* 将当前进程从等待队列中移除
* 打开中断
* 获得锁

#### signal操作:  

* 关中断
* 唤醒等待队列的队头
* 开中断
* 启动调度器进行进程调度

