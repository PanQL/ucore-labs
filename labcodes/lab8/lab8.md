## Lab8 实验报告  

---

### 知识点  

---

####  本次实验涉及到以下知识点:

* 基本的文件系统的系统调用方法
* 基于索引节点的SFS的设计与实现
* 文件系统抽象层的设计与实现

#### 下面这些知识点也很重要,但是本次实验没有体现:  

* 磁盘缓存
* IO子系统
* 磁盘调度算法

### 练习1  

---

#### sfs_io_nolock读文件中数据:  

要实现读文件中数据,我们可以使用的函数接口主要有:

* `sfs_buf_op`：带缓冲区的块操作.主要是用来进行非对齐块的读写操作.
* `sfs_block_op`：直接的块操作，用来进行对齐的块读写操作.
* `sfs_bmap_load_nolock`：根据相对于文件而言的块号，获得inode号.因为不是文件中所有连续的块在磁盘上都是连续分布的.

在sfs_io_nolock中,给入的参数已经足够确定读写的区域在磁盘扇区上的具体位置.需要解决的问题主要是:由于磁盘是按照块划分的,而给入的起止地址可能并不会按照块对齐.所以需要对读写的磁盘区域分情况讨论.

###### 读写的磁盘区域可以分为以下三种小区域来考虑:

* 位于大区域首部的未对齐的小区域
  * 处理方法:通过sfs_buf_op进行非对齐的磁盘读写
* 成块的小区域
  * 处理方法:通过sfs_block_op进行磁盘中块的读写
* 位于大区域尾部的未对齐的小区域
  * 处理方法:通过sfs_buf_op进行非对齐的磁盘读写  

同时还需要考虑一种比较特殊的情况,即起止地址都在同一个块内.这种情况我通过在处理大区域首部的未对齐小区域时,进行了特判,如果是起止地址在同一个块内,进行非对齐的读写之后,直接返回.

还需要注意的一点是,每次读取磁盘中的块,用到的块的序号,是需要经过函数sfs_bmap_load_nolock.经过与答案比较,我发现我在处理成块区域的时候,只调用了一次sfs_bmap_load_nolock,虽然能够通过现有的测试,但是这样是不正确的.因为当前文件中块号是连续的,并不代表在磁盘上各个块就一定是连续分布的.

#### PIPE的设计:  

##### 管道的创建: 

​	为创建管道，可以先创建一个类型为管道的inode,为管道在内存中分配一片缓冲区.然后,创建两个"打开的文件"(file结构体)以及对应的文件描述符,分别设置为只读/只写.最后将这两个文件描述符返回给用户.(可以返回映射之后的文件描述符,例如将文件描述符放入数组,返回其下标.)

##### 管道的使用:  

​	预分配的是有限大小的缓冲区,同一个文件分别与两个进程关联.这说明管道在实现的过程中需要解决读者-写者问题(这一问题慕课已经介绍过,不再重复).因此在管道使用时必须注意以下几点:

- 在对管道进行读/写操作时,如果缓冲区满,则需要停下读/写,唤醒对应的写者/读者(如果存在的话)
- 读者和写者不可以同时休眠,否则整个读写过程无法退出,导致死锁.

### 练习2

---

练习2主要需要完成两件事情:

* 实现将ELF格式的程序从磁盘加载到内存中,并设置好相应的虚拟地址.
* 为加载的用户程序设置传入参数.(通过手动设置用户堆栈)

#### 加载ELF格式的程序:

主要需要完成的有以下几点

* 建立该程序对应的内存管理器mm
* 初始化mm的页目录表
* 根据对应的文件描述符,从磁盘中读取ELF格式文件的文件头
* 解析ELF格式的文件头,获取程序在文件中的代码段以及bss段的虚拟地址,在文件中的具体位置,对应的读写权限等
* 根据上一步获取到的虚拟地址的范围,设置mm中可访问的虚拟地址范围.
* 将ELF文件中的代码段读入到内存中(按照每次读入的大小不超过一页,且注意地址按页大小对齐)
  * mm根据虚拟地址addr负责分配一个新的页page
  * 将磁盘中的代码段读入一页(或一页的一部分)到page中.
* 将ELF文件中的bss段读入到内存中,并清零
  * 获取bss段的起始虚拟地址和结束虚拟地址
  * 为该地址范围分配新的页,将页的内容清零,设置mm中pgdir的对应页表项.

#### 为用户栈传入参数:  

在此需要注意的一点是,由于传入参数的长度是不固定的,所以程序使用到的传入参数是指针.而程序能够访问到的堆栈只有用户堆栈,因此我们需要将参数本身以及指向参数的指针都压入栈.参数及指向参数的指针,在栈中的具体分布大致如下:

```c
  high address
----------------
|   argument   |
|      n       |
----------------<-+
|   argument   |  |
|    n - 1     |  |
----------------<-+-+
|     ...      |  | |
----------------  | |
|   argument   |  | |
|      2       |  | |
----------------<-+-+-+
|   argument   |  | | |
|      1       |  | | |
----------------<-+-+-+-+
|    padding   |  | | | |
----------------  | | | |
|   null ptr   |  | | | |
----------------  | | | |
|     ptr n    |--+ | | |
----------------    | | |
|     ptr n-1  |----+ | |
----------------      | |
|     ...      |      | |
----------------      | |
|     ptr 2    |------+ |
----------------        |
|     ptr 1    |--------+
----------------
|   arg count  | <-- user esp
----------------
  Low  Address  
```

所以在成功载入ELF格式的程序代码之后,还需完成的事情有:

* 赋予用户使用栈的权限.包括在mm中添加用户栈所在的虚拟地址的范围,为该范围新建页,设置对应页表项.
* 切换cr3中的页目录表地址为mm中的地址,之后可访问虚拟地址必须依据mm中的规定范围,否则会出现page_fault
* 计算传入参数的大小,分配在栈上分配用于存储参数及其指针的空间
* 将参数复制到栈中,并将参数在栈中的位置复制到参数指针所在的位置.(上图中的ptr x的位置)
* 将参数个数压入栈
* 在内核态设置中断帧,之后程序的执行将从中断处理例程返回之后开始.

#### 硬链接机制的设计:  

创建时:

* 将目录项的名字设定为指定的名字，目录项的inode号设置为目标文件的inode号
* 目标文件的innode引用数加一

删除时,只需要减少目标文件的inode的引用数

#### 软链接机制的设计:  

与硬链接不同的是,软链接文件就是一类特殊类型的文件，文件的数据为指向的目标文件或目录等的路径。

创建时,将对应的inode的类型设置为符号链接，文件的内容（数据）设置为目标文件路径字符串。

删除时于普通文件没有差别.