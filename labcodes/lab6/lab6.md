## Lab6 实验报告  

---

### 知识点  

#### 本次实验涉及到以下知识点：  

* 时间片轮转算法
* 调度器框架
* Stride Scheduling 调度算法

#### 以下知识点在本次实验中没有体现：

* 其他调度算法
* 多处理器调度
* 实时调度

### 练习1  

---

#### sched_class中各个函数指针的用法：  

##### init 

初始化调度器的内部结构，并且将进程个数计数器清零。

##### enqueue  

将一个新的进程加入到进程调度器中。同时将进程个数计数器加一。

##### dequeue 

将一个进程从进程调度器中移除，同时进程个数计数器减一。

##### pick_next  

用于进程调度过程中，在当前进程的时间片用完时，从进程调度器中选择一个新的进程并调用proc_run来执行他。

##### proc_tick

在每一次时钟中断的时候被调用，可以用于调整当前进程的时间片大小，并在当前进程时间片耗尽的时候进行调度。

#### 关于调度过程  

假设系统已经初始化好，当前进程剩余时间片为x。

此时，发生了时钟中断，`proc_tick`被调用，该进程时间片减少1后恢复运行，好像没有什么变化。

直到第x次发生时钟中断，`proc_tick`被调用，该进程时间片被减少到0，根据算法，当前进程的`need_resched`被设置为1，说明需要重新调度了。

中断处理程序发现`need_resched`被设置为1后，接下来会调用`schedule`，调度器真正开始发挥作用。

* 首先，内核会调用`enqueue`将当前进程放入调度器队列的尾部，放入时，RR调度器还会将这个进程的时间片增加为算法设定好的时间片最大值。
* 然后，调用`pick_next`从调度器队列首部选择下一个占用处理器的进程(如果存在的话),并将这一进程通过dequeue从调度器内部移除。
* 如果失败，说明没有进程可以运行，那么内核就让`idle`进程占用处理器。  

最后，内核调用`proc_run`开始执行新的进程。

#### 多级反馈队列算法--概要设计：  

为每一个优先级维护一个队列，记录每一个进程所在的优先级，根据进程对时间片的使用情况，调整进程的优先级。下面以各个接口为例，说明概要设计内容

* init：初始化算法维护的数据结构。
* enqueue：判断当前要进入队列的进程的时间片使用情况；

  * 如果时间片已经用完或恰好为初始值0，则认为该进程对时间片使用合理，加入对应优先级的队列中。

  * 如果该进程时间片为使用完，则降低其优先级，修改给该进程分配的时间片数量。将该进程加入到对应的优先级队列中。
* pick_next:采用某种调度算法,从对应的优先级队列中选择一个执行.
* dequeue:将对应的进程移出队列即可.

### 练习2  

---

#### 设计过程:  

* init:初始化斜堆,将进程个数计数器清零.
* enqueue:将新的进程插入斜堆,更新堆顶元素.
* dequeue:返回堆顶维护的stride最小的进程即可,同时需要注意将该进程的stride按照BIG_STRIDE / priority步进.
* proc_tick:减少该进程对应的时间片,如果该进程的时间片用完了,则将其置为需要调度状态.

#### 关于BIG_STRIDE的选取:  

​	由于 int 长度为 32 位，所以 BIG_STRIDE 取值为 int 范围内的最大的带符号整数：0x7FFFFFFF 。