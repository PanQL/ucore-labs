## Lab5实验报告  

----

### 知识点  

----

#### 本次实验中体现了以下知识点：  

* 进程状态模型

* 用户进程的相关知识

#### 以下知识点在本次实验中没有体现  

* 挂起进程

### 练习1  

----

* 主要就是修改`load_icode`，进行对`trapframe`结构体的初始化。 其中，`eip`需要设为ELF映像中定义的entry，`esp`则设为用户栈顶的虚拟地址，由于开启了分页，在这里，它只需要设置为一个常数`USTACKTOP`。

* 在一个进程被ucore选择为RUNNING状态之后，proc_run()将会被调用，在proc_run()中进行了：

  * 设置进程控制块指针，标记被选择进程的控制块为当前控制块。

  * 设置进程的内核栈以及页表。

  * 通过调用switch（）函数，修改进程在内核中的上下文，由于eip在这个过程中被修改为forkret，所以接下去执行forkret。

  * forkret跳转到__trapret,此时将会开始弹出中断帧的内容，设置用户进程初始运行状态。最后，用iret指令，同时完成跳转到用户进程的入口，特权级切换，栈切换这几个操作。开始执行用户进程的代码。

### 练习2 

---

* 对copy_range函数的补充。需要补充的地方是`copy_range`函数中拷贝内存和将页面映射信息填入页表的实现。
* 写时复制的概要设计：
  * 对于copy_range，在申请页面时，如果开启写时复制，则不再重新申请页面，直接将原先的页面链接到页表中。并且修改这个页面对应的所有页表项，将W位设置为不可写并刷新TLB。
  * 此时，对共享页面的写操作将会引发缺页异常，可以在do_pagefault中实现写时复制需要的页面分配。

### 练习3  

----

#### fork  

创建了一个新的进程控制块，设置进程状态为UNINIT，将当前进程几乎所有信息复制到新的进程。但不复制内核栈和用于存放返回值的`eax`寄存器。在`wakeup_proc`被调用之后，新的进程变为RUNNABLE（就绪态）。

#### exec  

不涉及进程切换，将当前mm的内存布局设置为指定的ELF文件的内存布局。

#### wait  

* 首先检查当前进程是否有子进程，若无则直接返回错误。
* 然后检查是否有ZOMBIE状态的子进程，若有则直接释放子进程残存的资源，然后立即返回子进程的返回状态码。
* 若没有ZOMBIE状态的子进程，父进程变为SLEEPING状态，等待这样的子进程出现，然后再进行上面的操作。

#### exit  

* 清除当前进程的资源。
* 将当前进程的所有子进程的父进程设置为init进程。
* 将当前进程的状态设为ZOMBIE
* 查看该进程是否有父进程，若有，则将父进程的状态有SLEEPING转到RUNNABLE。

#### 状态转移图：  

```c
		+----------------->SLEEPING----------------+
		|    1               |            7        |
		|                    | 4                   |
        |					 |	 	               |
        |   2        		 V   				   V     8
UNINIT-------------------->RUNNABLE------------->ZOMBIE----->
        |                    |  A                  A
        |                  6 |  |5                 |
        |                    |  |                  |
        |    3               V  |         7        |
        +----------------->RUNNING-----------------+
```

1. 调用wait（）

2. 

3. 调用wakeup_proc()

4. 子进程调用exit（）

5. 调用了proc_run()

6. 作为proc_run的传入参数而被运行。

7. 调用exit（）

8. 父进程调用了wait（）

